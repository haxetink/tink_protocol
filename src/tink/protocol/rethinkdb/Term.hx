package tink.protocol.rethinkdb;

import haxe.Json;
import haxe.io.Bytes;
import haxe.io.BytesOutput;

using tink.protocol.rethinkdb.Datum;
using tink.CoreApi;

class TermTools {
		
	public static function asString(v:Term):String {
		
		return switch v {
			case null: DNull.asString();
			case TDatum(datum): DatumTools.asString(datum);
			case TMakeArray(args, opt): '[$MAKE_ARRAY,${argsToString(args)}${opt.toString()}]';
			case TMakeObj(args, opt): '[$MAKE_OBJ,${argsToString(args)}${opt.toString()}]';
			case TVar(args, opt): '[$VAR,${argsToString(args)}${opt.toString()}]';
			case TJavascript(args, opt): '[$JAVASCRIPT,${argsToString(args)}${opt.toString()}]';
			case TUuid(args, opt): '[$UUID,${argsToString(args)}${opt.toString()}]';
			case THttp(args, opt): '[$HTTP,${argsToString(args)}${opt.toString()}]';
			case TError(args, opt): '[$ERROR,${argsToString(args)}${opt.toString()}]';
			case TImplicitVar(args, opt): '[$IMPLICIT_VAR,${argsToString(args)}${opt.toString()}]';
			case TDb(args, opt): '[$DB,${argsToString(args)}${opt.toString()}]';
			case TTable(args, opt): '[$TABLE,${argsToString(args)}${opt.toString()}]';
			case TGet(args, opt): '[$GET,${argsToString(args)}${opt.toString()}]';
			case TGetAll(args, opt): '[$GET_ALL,${argsToString(args)}${opt.toString()}]';
			case TEq(args, opt): '[$EQ,${argsToString(args)}${opt.toString()}]';
			case TNe(args, opt): '[$NE,${argsToString(args)}${opt.toString()}]';
			case TLt(args, opt): '[$LT,${argsToString(args)}${opt.toString()}]';
			case TLe(args, opt): '[$LE,${argsToString(args)}${opt.toString()}]';
			case TGt(args, opt): '[$GT,${argsToString(args)}${opt.toString()}]';
			case TGe(args, opt): '[$GE,${argsToString(args)}${opt.toString()}]';
			case TNot(args, opt): '[$NOT,${argsToString(args)}${opt.toString()}]';
			case TAdd(args, opt): '[$ADD,${argsToString(args)}${opt.toString()}]';
			case TSub(args, opt): '[$SUB,${argsToString(args)}${opt.toString()}]';
			case TMul(args, opt): '[$MUL,${argsToString(args)}${opt.toString()}]';
			case TDiv(args, opt): '[$DIV,${argsToString(args)}${opt.toString()}]';
			case TMod(args, opt): '[$MOD,${argsToString(args)}${opt.toString()}]';
			case TFloor(args, opt): '[$FLOOR,${argsToString(args)}${opt.toString()}]';
			case TCeil(args, opt): '[$CEIL,${argsToString(args)}${opt.toString()}]';
			case TRound(args, opt): '[$ROUND,${argsToString(args)}${opt.toString()}]';
			case TAppend(args, opt): '[$APPEND,${argsToString(args)}${opt.toString()}]';
			case TPrepend(args, opt): '[$PREPEND,${argsToString(args)}${opt.toString()}]';
			case TDifference(args, opt): '[$DIFFERENCE,${argsToString(args)}${opt.toString()}]';
			case TSetInsert(args, opt): '[$SET_INSERT,${argsToString(args)}${opt.toString()}]';
			case TSetIntersection(args, opt): '[$SET_INTERSECTION,${argsToString(args)}${opt.toString()}]';
			case TSetUnion(args, opt): '[$SET_UNION,${argsToString(args)}${opt.toString()}]';
			case TSetDifference(args, opt): '[$SET_DIFFERENCE,${argsToString(args)}${opt.toString()}]';
			case TSlice(args, opt): '[$SLICE,${argsToString(args)}${opt.toString()}]';
			case TSkip(args, opt): '[$SKIP,${argsToString(args)}${opt.toString()}]';
			case TLimit(args, opt): '[$LIMIT,${argsToString(args)}${opt.toString()}]';
			case TOffsetsOf(args, opt): '[$OFFSETS_OF,${argsToString(args)}${opt.toString()}]';
			case TContains(args, opt): '[$CONTAINS,${argsToString(args)}${opt.toString()}]';
			case TGetField(args, opt): '[$GET_FIELD,${argsToString(args)}${opt.toString()}]';
			case TKeys(args, opt): '[$KEYS,${argsToString(args)}${opt.toString()}]';
			case TValues(args, opt): '[$VALUES,${argsToString(args)}${opt.toString()}]';
			case TObject(args, opt): '[$OBJECT,${argsToString(args)}${opt.toString()}]';
			case THasFields(args, opt): '[$HAS_FIELDS,${argsToString(args)}${opt.toString()}]';
			case TWithFields(args, opt): '[$WITH_FIELDS,${argsToString(args)}${opt.toString()}]';
			case TPluck(args, opt): '[$PLUCK,${argsToString(args)}${opt.toString()}]';
			case TWithout(args, opt): '[$WITHOUT,${argsToString(args)}${opt.toString()}]';
			case TMerge(args, opt): '[$MERGE,${argsToString(args)}${opt.toString()}]';
			case TBetweenDeprecated(args, opt): '[$BETWEEN_DEPRECATED,${argsToString(args)}${opt.toString()}]';
			case TBetween(args, opt): '[$BETWEEN,${argsToString(args)}${opt.toString()}]';
			case TReduce(args, opt): '[$REDUCE,${argsToString(args)}${opt.toString()}]';
			case TMap(args, opt): '[$MAP,${argsToString(args)}${opt.toString()}]';
			case TFold(args, opt): '[$FOLD,${argsToString(args)}${opt.toString()}]';
			case TFilter(args, opt): '[$FILTER,${argsToString(args)}${opt.toString()}]';
			case TConcatMap(args, opt): '[$CONCAT_MAP,${argsToString(args)}${opt.toString()}]';
			case TOrderBy(args, opt): '[$ORDER_BY,${argsToString(args)}${opt.toString()}]';
			case TDistinct(args, opt): '[$DISTINCT,${argsToString(args)}${opt.toString()}]';
			case TCount(args, opt): '[$COUNT,${argsToString(args)}${opt.toString()}]';
			case TIsEmpty(args, opt): '[$IS_EMPTY,${argsToString(args)}${opt.toString()}]';
			case TUnion(args, opt): '[$UNION,${argsToString(args)}${opt.toString()}]';
			case TNth(args, opt): '[$NTH,${argsToString(args)}${opt.toString()}]';
			case TBracket(args, opt): '[$BRACKET,${argsToString(args)}${opt.toString()}]';
			case TInnerJoin(args, opt): '[$INNER_JOIN,${argsToString(args)}${opt.toString()}]';
			case TOuterJoin(args, opt): '[$OUTER_JOIN,${argsToString(args)}${opt.toString()}]';
			case TEqJoin(args, opt): '[$EQ_JOIN,${argsToString(args)}${opt.toString()}]';
			case TZip(args, opt): '[$ZIP,${argsToString(args)}${opt.toString()}]';
			case TRange(args, opt): '[$RANGE,${argsToString(args)}${opt.toString()}]';
			case TInsertAt(args, opt): '[$INSERT_AT,${argsToString(args)}${opt.toString()}]';
			case TDeleteAt(args, opt): '[$DELETE_AT,${argsToString(args)}${opt.toString()}]';
			case TChangeAt(args, opt): '[$CHANGE_AT,${argsToString(args)}${opt.toString()}]';
			case TSpliceAt(args, opt): '[$SPLICE_AT,${argsToString(args)}${opt.toString()}]';
			case TCoerceTo(args, opt): '[$COERCE_TO,${argsToString(args)}${opt.toString()}]';
			case TTypeOf(args, opt): '[$TYPE_OF,${argsToString(args)}${opt.toString()}]';
			case TUpdate(args, opt): '[$UPDATE,${argsToString(args)}${opt.toString()}]';
			case TDelete(args, opt): '[$DELETE,${argsToString(args)}${opt.toString()}]';
			case TReplace(args, opt): '[$REPLACE,${argsToString(args)}${opt.toString()}]';
			case TInsert(args, opt): '[$INSERT,${argsToString(args)}${opt.toString()}]';
			case TDbCreate(args, opt): '[$DB_CREATE,${argsToString(args)}${opt.toString()}]';
			case TDbDrop(args, opt): '[$DB_DROP,${argsToString(args)}${opt.toString()}]';
			case TDbList(args, opt): '[$DB_LIST,${argsToString(args)}${opt.toString()}]';
			case TTableCreate(args, opt): '[$TABLE_CREATE,${argsToString(args)}${opt.toString()}]';
			case TTableDrop(args, opt): '[$TABLE_DROP,${argsToString(args)}${opt.toString()}]';
			case TTableList(args, opt): '[$TABLE_LIST,${argsToString(args)}${opt.toString()}]';
			case TConfig(args, opt): '[$CONFIG,${argsToString(args)}${opt.toString()}]';
			case TStatus(args, opt): '[$STATUS,${argsToString(args)}${opt.toString()}]';
			case TWait(args, opt): '[$WAIT,${argsToString(args)}${opt.toString()}]';
			case TReconfigure(args, opt): '[$RECONFIGURE,${argsToString(args)}${opt.toString()}]';
			case TRebalance(args, opt): '[$REBALANCE,${argsToString(args)}${opt.toString()}]';
			case TSync(args, opt): '[$SYNC,${argsToString(args)}${opt.toString()}]';
			case TGrant(args, opt): '[$GRANT,${argsToString(args)}${opt.toString()}]';
			case TIndexCreate(args, opt): '[$INDEX_CREATE,${argsToString(args)}${opt.toString()}]';
			case TIndexDrop(args, opt): '[$INDEX_DROP,${argsToString(args)}${opt.toString()}]';
			case TIndexList(args, opt): '[$INDEX_LIST,${argsToString(args)}${opt.toString()}]';
			case TIndexStatus(args, opt): '[$INDEX_STATUS,${argsToString(args)}${opt.toString()}]';
			case TIndexWait(args, opt): '[$INDEX_WAIT,${argsToString(args)}${opt.toString()}]';
			case TIndexRename(args, opt): '[$INDEX_RENAME,${argsToString(args)}${opt.toString()}]';
			case TSetWriteHook(args, opt): '[$SET_WRITE_HOOK,${argsToString(args)}${opt.toString()}]';
			case TGetWriteHook(args, opt): '[$GET_WRITE_HOOK,${argsToString(args)}${opt.toString()}]';
			case TFuncall(args, opt): '[$FUNCALL,${argsToString(args)}${opt.toString()}]';
			case TBranch(args, opt): '[$BRANCH,${argsToString(args)}${opt.toString()}]';
			case TOr(args, opt): '[$OR,${argsToString(args)}${opt.toString()}]';
			case TAnd(args, opt): '[$AND,${argsToString(args)}${opt.toString()}]';
			case TForEach(args, opt): '[$FOR_EACH,${argsToString(args)}${opt.toString()}]';
			case TFunc(args, opt): '[$FUNC,${argsToString(args)}${opt.toString()}]';
			case TAsc(args, opt): '[$ASC,${argsToString(args)}${opt.toString()}]';
			case TDesc(args, opt): '[$DESC,${argsToString(args)}${opt.toString()}]';
			case TInfo(args, opt): '[$INFO,${argsToString(args)}${opt.toString()}]';
			case TMatch(args, opt): '[$MATCH,${argsToString(args)}${opt.toString()}]';
			case TUpcase(args, opt): '[$UPCASE,${argsToString(args)}${opt.toString()}]';
			case TDowncase(args, opt): '[$DOWNCASE,${argsToString(args)}${opt.toString()}]';
			case TSample(args, opt): '[$SAMPLE,${argsToString(args)}${opt.toString()}]';
			case TDefault(args, opt): '[$DEFAULT,${argsToString(args)}${opt.toString()}]';
			case TJson(args, opt): '[$JSON,${argsToString(args)}${opt.toString()}]';
			case TToJsonString(args, opt): '[$TO_JSON_STRING,${argsToString(args)}${opt.toString()}]';
			case TIso8601(args, opt): '[$ISO8601,${argsToString(args)}${opt.toString()}]';
			case TToIso8601(args, opt): '[$TO_ISO8601,${argsToString(args)}${opt.toString()}]';
			case TEpochTime(args, opt): '[$EPOCH_TIME,${argsToString(args)}${opt.toString()}]';
			case TToEpochTime(args, opt): '[$TO_EPOCH_TIME,${argsToString(args)}${opt.toString()}]';
			case TNow(args, opt): '[$NOW,${argsToString(args)}${opt.toString()}]';
			case TInTimezone(args, opt): '[$IN_TIMEZONE,${argsToString(args)}${opt.toString()}]';
			case TDuring(args, opt): '[$DURING,${argsToString(args)}${opt.toString()}]';
			case TDate(args, opt): '[$DATE,${argsToString(args)}${opt.toString()}]';
			case TTimeOfDay(args, opt): '[$TIME_OF_DAY,${argsToString(args)}${opt.toString()}]';
			case TTimezone(args, opt): '[$TIMEZONE,${argsToString(args)}${opt.toString()}]';
			case TYear(args, opt): '[$YEAR,${argsToString(args)}${opt.toString()}]';
			case TMonth(args, opt): '[$MONTH,${argsToString(args)}${opt.toString()}]';
			case TDay(args, opt): '[$DAY,${argsToString(args)}${opt.toString()}]';
			case TDayOfWeek(args, opt): '[$DAY_OF_WEEK,${argsToString(args)}${opt.toString()}]';
			case TDayOfYear(args, opt): '[$DAY_OF_YEAR,${argsToString(args)}${opt.toString()}]';
			case THours(args, opt): '[$HOURS,${argsToString(args)}${opt.toString()}]';
			case TMinutes(args, opt): '[$MINUTES,${argsToString(args)}${opt.toString()}]';
			case TSeconds(args, opt): '[$SECONDS,${argsToString(args)}${opt.toString()}]';
			case TTime(args, opt): '[$TIME,${argsToString(args)}${opt.toString()}]';
			case TMonday(args, opt): '[$MONDAY,${argsToString(args)}${opt.toString()}]';
			case TTuesday(args, opt): '[$TUESDAY,${argsToString(args)}${opt.toString()}]';
			case TWednesday(args, opt): '[$WEDNESDAY,${argsToString(args)}${opt.toString()}]';
			case TThursday(args, opt): '[$THURSDAY,${argsToString(args)}${opt.toString()}]';
			case TFriday(args, opt): '[$FRIDAY,${argsToString(args)}${opt.toString()}]';
			case TSaturday(args, opt): '[$SATURDAY,${argsToString(args)}${opt.toString()}]';
			case TSunday(args, opt): '[$SUNDAY,${argsToString(args)}${opt.toString()}]';
			case TJanuary(args, opt): '[$JANUARY,${argsToString(args)}${opt.toString()}]';
			case TFebruary(args, opt): '[$FEBRUARY,${argsToString(args)}${opt.toString()}]';
			case TMarch(args, opt): '[$MARCH,${argsToString(args)}${opt.toString()}]';
			case TApril(args, opt): '[$APRIL,${argsToString(args)}${opt.toString()}]';
			case TMay(args, opt): '[$MAY,${argsToString(args)}${opt.toString()}]';
			case TJune(args, opt): '[$JUNE,${argsToString(args)}${opt.toString()}]';
			case TJuly(args, opt): '[$JULY,${argsToString(args)}${opt.toString()}]';
			case TAugust(args, opt): '[$AUGUST,${argsToString(args)}${opt.toString()}]';
			case TSeptember(args, opt): '[$SEPTEMBER,${argsToString(args)}${opt.toString()}]';
			case TOctober(args, opt): '[$OCTOBER,${argsToString(args)}${opt.toString()}]';
			case TNovember(args, opt): '[$NOVEMBER,${argsToString(args)}${opt.toString()}]';
			case TDecember(args, opt): '[$DECEMBER,${argsToString(args)}${opt.toString()}]';
			case TLiteral(args, opt): '[$LITERAL,${argsToString(args)}${opt.toString()}]';
			case TGroup(args, opt): '[$GROUP,${argsToString(args)}${opt.toString()}]';
			case TSum(args, opt): '[$SUM,${argsToString(args)}${opt.toString()}]';
			case TAvg(args, opt): '[$AVG,${argsToString(args)}${opt.toString()}]';
			case TMin(args, opt): '[$MIN,${argsToString(args)}${opt.toString()}]';
			case TMax(args, opt): '[$MAX,${argsToString(args)}${opt.toString()}]';
			case TSplit(args, opt): '[$SPLIT,${argsToString(args)}${opt.toString()}]';
			case TUngroup(args, opt): '[$UNGROUP,${argsToString(args)}${opt.toString()}]';
			case TRandom(args, opt): '[$RANDOM,${argsToString(args)}${opt.toString()}]';
			case TChanges(args, opt): '[$CHANGES,${argsToString(args)}${opt.toString()}]';
			case TArgs(args, opt): '[$ARGS,${argsToString(args)}${opt.toString()}]';
			case TBinary(args, opt): '[$BINARY,${argsToString(args)}${opt.toString()}]';
			case TGeojson(args, opt): '[$GEOJSON,${argsToString(args)}${opt.toString()}]';
			case TToGeojson(args, opt): '[$TO_GEOJSON,${argsToString(args)}${opt.toString()}]';
			case TPoint(args, opt): '[$POINT,${argsToString(args)}${opt.toString()}]';
			case TLine(args, opt): '[$LINE,${argsToString(args)}${opt.toString()}]';
			case TPolygon(args, opt): '[$POLYGON,${argsToString(args)}${opt.toString()}]';
			case TDistance(args, opt): '[$DISTANCE,${argsToString(args)}${opt.toString()}]';
			case TIntersects(args, opt): '[$INTERSECTS,${argsToString(args)}${opt.toString()}]';
			case TIncludes(args, opt): '[$INCLUDES,${argsToString(args)}${opt.toString()}]';
			case TCircle(args, opt): '[$CIRCLE,${argsToString(args)}${opt.toString()}]';
			case TGetIntersecting(args, opt): '[$GET_INTERSECTING,${argsToString(args)}${opt.toString()}]';
			case TFill(args, opt): '[$FILL,${argsToString(args)}${opt.toString()}]';
			case TGetNearest(args, opt): '[$GET_NEAREST,${argsToString(args)}${opt.toString()}]';
			case TPolygonSub(args, opt): '[$POLYGON_SUB,${argsToString(args)}${opt.toString()}]';
			case TMinval(args, opt): '[$MINVAL,${argsToString(args)}${opt.toString()}]';
			case TMaxval(args, opt): '[$MAXVAL,${argsToString(args)}${opt.toString()}]';
		}
	}
	
	static function argsToString(v:Array<Term>):String
		return '[' + [for(i in v) asString(i)].join(',') + ']';
	
}

@:forward
abstract TermOptions(Array<Named<Term>>) from Array<Named<Term>> to Array<Named<Term>> {
	@:from
	public static function fromStruct(opt:{}):TermOptions
		return opt == null ? null : [for(f in Reflect.fields(opt)) new NamedWith(f, TDatum(DatumTools.ofAny(Reflect.field(opt, f))))];
		
	@:to
	public function toString():String
		return this == null ? '' : ',{' + [for(o in this) '"${o.name}":${TermTools.asString(o.value)}'].join(',') + '}';
}

@:enum
abstract TermType(Int) from Int {
	var DATUM = 1;
	var MAKE_ARRAY = 2;
	var MAKE_OBJ = 3;
	var VAR = 10;
	var JAVASCRIPT = 11;
	var UUID = 169;
	var HTTP = 153;
	var ERROR = 12;
	var IMPLICIT_VAR = 13;
	var DB = 14;
	var TABLE = 15;
	var GET = 16;
	var GET_ALL = 78;
	var EQ = 17;
	var NE = 18;
	var LT = 19;
	var LE = 20;
	var GT = 21;
	var GE = 22;
	var NOT = 23;
	var ADD = 24;
	var SUB = 25;
	var MUL = 26;
	var DIV = 27;
	var MOD = 28;
	var FLOOR = 183;
	var CEIL = 184;
	var ROUND = 185;
	var APPEND = 29;
	var PREPEND = 80;
	var DIFFERENCE = 95;
	var SET_INSERT = 88;
	var SET_INTERSECTION = 89;
	var SET_UNION = 90;
	var SET_DIFFERENCE = 91;
	var SLICE = 30;
	var SKIP = 70;
	var LIMIT = 71;
	var OFFSETS_OF = 87;
	var CONTAINS = 93;
	var GET_FIELD = 31;
	var KEYS = 94;
	var VALUES = 186;
	var OBJECT = 143;
	var HAS_FIELDS = 32;
	var WITH_FIELDS = 96;
	var PLUCK = 33;
	var WITHOUT = 34;
	var MERGE = 35;
	var BETWEEN_DEPRECATED = 36;
	var BETWEEN = 182;
	var REDUCE = 37;
	var MAP = 38;
	var FOLD = 187;
	var FILTER = 39;
	var CONCAT_MAP = 40;
	var ORDER_BY = 41;
	var DISTINCT = 42;
	var COUNT = 43;
	var IS_EMPTY = 86;
	var UNION = 44;
	var NTH = 45;
	var BRACKET = 170;
	var INNER_JOIN = 48;
	var OUTER_JOIN = 49;
	var EQ_JOIN = 50;
	var ZIP = 72;
	var RANGE = 173;
	var INSERT_AT = 82;
	var DELETE_AT = 83;
	var CHANGE_AT = 84;
	var SPLICE_AT = 85;
	var COERCE_TO = 51;
	var TYPE_OF = 52;
	var UPDATE = 53;
	var DELETE = 54;
	var REPLACE = 55;
	var INSERT = 56;
	var DB_CREATE = 57;
	var DB_DROP = 58;
	var DB_LIST = 59;
	var TABLE_CREATE = 60;
	var TABLE_DROP = 61;
	var TABLE_LIST = 62;
	var CONFIG = 174;
	var STATUS = 175;
	var WAIT = 177;
	var RECONFIGURE = 176;
	var REBALANCE = 179;
	var SYNC = 138;
	var GRANT = 188;
	var INDEX_CREATE = 75;
	var INDEX_DROP = 76;
	var INDEX_LIST = 77;
	var INDEX_STATUS = 139;
	var INDEX_WAIT = 140;
	var INDEX_RENAME = 156;
	var SET_WRITE_HOOK = 189;
	var GET_WRITE_HOOK = 190;
	var FUNCALL = 64;
	var BRANCH = 65;
	var OR = 66;
	var AND = 67;
	var FOR_EACH = 68;
	var FUNC = 69;
	var ASC = 73;
	var DESC = 74;
	var INFO = 79;
	var MATCH = 97;
	var UPCASE = 141;
	var DOWNCASE = 142;
	var SAMPLE = 81;
	var DEFAULT = 92;
	var JSON = 98;
	var TO_JSON_STRING = 172;
	var ISO8601 = 99;
	var TO_ISO8601 = 100;
	var EPOCH_TIME = 101;
	var TO_EPOCH_TIME = 102;
	var NOW = 103;
	var IN_TIMEZONE = 104;
	var DURING = 105;
	var DATE = 106;
	var TIME_OF_DAY = 126;
	var TIMEZONE = 127;
	var YEAR = 128;
	var MONTH = 129;
	var DAY = 130;
	var DAY_OF_WEEK = 131;
	var DAY_OF_YEAR = 132;
	var HOURS = 133;
	var MINUTES = 134;
	var SECONDS = 135;
	var TIME = 136;
	var MONDAY = 107;
	var TUESDAY = 108;
	var WEDNESDAY = 109;
	var THURSDAY = 110;
	var FRIDAY = 111;
	var SATURDAY = 112;
	var SUNDAY = 113;
	var JANUARY = 114;
	var FEBRUARY = 115;
	var MARCH = 116;
	var APRIL = 117;
	var MAY = 118;
	var JUNE = 119;
	var JULY = 120;
	var AUGUST = 121;
	var SEPTEMBER = 122;
	var OCTOBER = 123;
	var NOVEMBER = 124;
	var DECEMBER = 125;
	var LITERAL = 137;
	var GROUP = 144;
	var SUM = 145;
	var AVG = 146;
	var MIN = 147;
	var MAX = 148;
	var SPLIT = 149;
	var UNGROUP = 150;
	var RANDOM = 151;
	var CHANGES = 152;
	var ARGS = 154;
	var BINARY = 155;
	var GEOJSON = 157;
	var TO_GEOJSON = 158;
	var POINT = 159;
	var LINE = 160;
	var POLYGON = 161;
	var DISTANCE = 162;
	var INTERSECTS = 163;
	var INCLUDES = 164;
	var CIRCLE = 165;
	var GET_INTERSECTING = 166;
	var FILL = 167;
	var GET_NEAREST = 168;
	var POLYGON_SUB = 171;
	var MINVAL = 180;
	var MAXVAL = 181;
}

enum Term {
	TDatum(datum:Datum);
	TMakeArray(args:Array<Term>, ?options:TermOptions);
	TMakeObj(args:Array<Term>, ?options:TermOptions);
	TVar(args:Array<Term>, ?options:TermOptions);
	TJavascript(args:Array<Term>, ?options:TermOptions);
	TUuid(args:Array<Term>, ?options:TermOptions);
	THttp(args:Array<Term>, ?options:TermOptions);
	TError(args:Array<Term>, ?options:TermOptions);
	TImplicitVar(args:Array<Term>, ?options:TermOptions);
	TDb(args:Array<Term>, ?options:TermOptions);
	TTable(args:Array<Term>, ?options:TermOptions);
	TGet(args:Array<Term>, ?options:TermOptions);
	TGetAll(args:Array<Term>, ?options:TermOptions);
	TEq(args:Array<Term>, ?options:TermOptions);
	TNe(args:Array<Term>, ?options:TermOptions);
	TLt(args:Array<Term>, ?options:TermOptions);
	TLe(args:Array<Term>, ?options:TermOptions);
	TGt(args:Array<Term>, ?options:TermOptions);
	TGe(args:Array<Term>, ?options:TermOptions);
	TNot(args:Array<Term>, ?options:TermOptions);
	TAdd(args:Array<Term>, ?options:TermOptions);
	TSub(args:Array<Term>, ?options:TermOptions);
	TMul(args:Array<Term>, ?options:TermOptions);
	TDiv(args:Array<Term>, ?options:TermOptions);
	TMod(args:Array<Term>, ?options:TermOptions);
	TFloor(args:Array<Term>, ?options:TermOptions);
	TCeil(args:Array<Term>, ?options:TermOptions);
	TRound(args:Array<Term>, ?options:TermOptions);
	TAppend(args:Array<Term>, ?options:TermOptions);
	TPrepend(args:Array<Term>, ?options:TermOptions);
	TDifference(args:Array<Term>, ?options:TermOptions);
	TSetInsert(args:Array<Term>, ?options:TermOptions);
	TSetIntersection(args:Array<Term>, ?options:TermOptions);
	TSetUnion(args:Array<Term>, ?options:TermOptions);
	TSetDifference(args:Array<Term>, ?options:TermOptions);
	TSlice(args:Array<Term>, ?options:TermOptions);
	TSkip(args:Array<Term>, ?options:TermOptions);
	TLimit(args:Array<Term>, ?options:TermOptions);
	TOffsetsOf(args:Array<Term>, ?options:TermOptions);
	TContains(args:Array<Term>, ?options:TermOptions);
	TGetField(args:Array<Term>, ?options:TermOptions);
	TKeys(args:Array<Term>, ?options:TermOptions);
	TValues(args:Array<Term>, ?options:TermOptions);
	TObject(args:Array<Term>, ?options:TermOptions);
	THasFields(args:Array<Term>, ?options:TermOptions);
	TWithFields(args:Array<Term>, ?options:TermOptions);
	TPluck(args:Array<Term>, ?options:TermOptions);
	TWithout(args:Array<Term>, ?options:TermOptions);
	TMerge(args:Array<Term>, ?options:TermOptions);
	TBetweenDeprecated(args:Array<Term>, ?options:TermOptions);
	TBetween(args:Array<Term>, ?options:TermOptions);
	TReduce(args:Array<Term>, ?options:TermOptions);
	TMap(args:Array<Term>, ?options:TermOptions);
	TFold(args:Array<Term>, ?options:TermOptions);
	TFilter(args:Array<Term>, ?options:TermOptions);
	TConcatMap(args:Array<Term>, ?options:TermOptions);
	TOrderBy(args:Array<Term>, ?options:TermOptions);
	TDistinct(args:Array<Term>, ?options:TermOptions);
	TCount(args:Array<Term>, ?options:TermOptions);
	TIsEmpty(args:Array<Term>, ?options:TermOptions);
	TUnion(args:Array<Term>, ?options:TermOptions);
	TNth(args:Array<Term>, ?options:TermOptions);
	TBracket(args:Array<Term>, ?options:TermOptions);
	TInnerJoin(args:Array<Term>, ?options:TermOptions);
	TOuterJoin(args:Array<Term>, ?options:TermOptions);
	TEqJoin(args:Array<Term>, ?options:TermOptions);
	TZip(args:Array<Term>, ?options:TermOptions);
	TRange(args:Array<Term>, ?options:TermOptions);
	TInsertAt(args:Array<Term>, ?options:TermOptions);
	TDeleteAt(args:Array<Term>, ?options:TermOptions);
	TChangeAt(args:Array<Term>, ?options:TermOptions);
	TSpliceAt(args:Array<Term>, ?options:TermOptions);
	TCoerceTo(args:Array<Term>, ?options:TermOptions);
	TTypeOf(args:Array<Term>, ?options:TermOptions);
	TUpdate(args:Array<Term>, ?options:TermOptions);
	TDelete(args:Array<Term>, ?options:TermOptions);
	TReplace(args:Array<Term>, ?options:TermOptions);
	TInsert(args:Array<Term>, ?options:TermOptions);
	TDbCreate(args:Array<Term>, ?options:TermOptions);
	TDbDrop(args:Array<Term>, ?options:TermOptions);
	TDbList(args:Array<Term>, ?options:TermOptions);
	TTableCreate(args:Array<Term>, ?options:TermOptions);
	TTableDrop(args:Array<Term>, ?options:TermOptions);
	TTableList(args:Array<Term>, ?options:TermOptions);
	TConfig(args:Array<Term>, ?options:TermOptions);
	TStatus(args:Array<Term>, ?options:TermOptions);
	TWait(args:Array<Term>, ?options:TermOptions);
	TReconfigure(args:Array<Term>, ?options:TermOptions);
	TRebalance(args:Array<Term>, ?options:TermOptions);
	TSync(args:Array<Term>, ?options:TermOptions);
	TGrant(args:Array<Term>, ?options:TermOptions);
	TIndexCreate(args:Array<Term>, ?options:TermOptions);
	TIndexDrop(args:Array<Term>, ?options:TermOptions);
	TIndexList(args:Array<Term>, ?options:TermOptions);
	TIndexStatus(args:Array<Term>, ?options:TermOptions);
	TIndexWait(args:Array<Term>, ?options:TermOptions);
	TIndexRename(args:Array<Term>, ?options:TermOptions);
	TSetWriteHook(args:Array<Term>, ?options:TermOptions);
	TGetWriteHook(args:Array<Term>, ?options:TermOptions);
	TFuncall(args:Array<Term>, ?options:TermOptions);
	TBranch(args:Array<Term>, ?options:TermOptions);
	TOr(args:Array<Term>, ?options:TermOptions);
	TAnd(args:Array<Term>, ?options:TermOptions);
	TForEach(args:Array<Term>, ?options:TermOptions);
	TFunc(args:Array<Term>, ?options:TermOptions);
	TAsc(args:Array<Term>, ?options:TermOptions);
	TDesc(args:Array<Term>, ?options:TermOptions);
	TInfo(args:Array<Term>, ?options:TermOptions);
	TMatch(args:Array<Term>, ?options:TermOptions);
	TUpcase(args:Array<Term>, ?options:TermOptions);
	TDowncase(args:Array<Term>, ?options:TermOptions);
	TSample(args:Array<Term>, ?options:TermOptions);
	TDefault(args:Array<Term>, ?options:TermOptions);
	TJson(args:Array<Term>, ?options:TermOptions);
	TToJsonString(args:Array<Term>, ?options:TermOptions);
	TIso8601(args:Array<Term>, ?options:TermOptions);
	TToIso8601(args:Array<Term>, ?options:TermOptions);
	TEpochTime(args:Array<Term>, ?options:TermOptions);
	TToEpochTime(args:Array<Term>, ?options:TermOptions);
	TNow(args:Array<Term>, ?options:TermOptions);
	TInTimezone(args:Array<Term>, ?options:TermOptions);
	TDuring(args:Array<Term>, ?options:TermOptions);
	TDate(args:Array<Term>, ?options:TermOptions);
	TTimeOfDay(args:Array<Term>, ?options:TermOptions);
	TTimezone(args:Array<Term>, ?options:TermOptions);
	TYear(args:Array<Term>, ?options:TermOptions);
	TMonth(args:Array<Term>, ?options:TermOptions);
	TDay(args:Array<Term>, ?options:TermOptions);
	TDayOfWeek(args:Array<Term>, ?options:TermOptions);
	TDayOfYear(args:Array<Term>, ?options:TermOptions);
	THours(args:Array<Term>, ?options:TermOptions);
	TMinutes(args:Array<Term>, ?options:TermOptions);
	TSeconds(args:Array<Term>, ?options:TermOptions);
	TTime(args:Array<Term>, ?options:TermOptions);
	TMonday(args:Array<Term>, ?options:TermOptions);
	TTuesday(args:Array<Term>, ?options:TermOptions);
	TWednesday(args:Array<Term>, ?options:TermOptions);
	TThursday(args:Array<Term>, ?options:TermOptions);
	TFriday(args:Array<Term>, ?options:TermOptions);
	TSaturday(args:Array<Term>, ?options:TermOptions);
	TSunday(args:Array<Term>, ?options:TermOptions);
	TJanuary(args:Array<Term>, ?options:TermOptions);
	TFebruary(args:Array<Term>, ?options:TermOptions);
	TMarch(args:Array<Term>, ?options:TermOptions);
	TApril(args:Array<Term>, ?options:TermOptions);
	TMay(args:Array<Term>, ?options:TermOptions);
	TJune(args:Array<Term>, ?options:TermOptions);
	TJuly(args:Array<Term>, ?options:TermOptions);
	TAugust(args:Array<Term>, ?options:TermOptions);
	TSeptember(args:Array<Term>, ?options:TermOptions);
	TOctober(args:Array<Term>, ?options:TermOptions);
	TNovember(args:Array<Term>, ?options:TermOptions);
	TDecember(args:Array<Term>, ?options:TermOptions);
	TLiteral(args:Array<Term>, ?options:TermOptions);
	TGroup(args:Array<Term>, ?options:TermOptions);
	TSum(args:Array<Term>, ?options:TermOptions);
	TAvg(args:Array<Term>, ?options:TermOptions);
	TMin(args:Array<Term>, ?options:TermOptions);
	TMax(args:Array<Term>, ?options:TermOptions);
	TSplit(args:Array<Term>, ?options:TermOptions);
	TUngroup(args:Array<Term>, ?options:TermOptions);
	TRandom(args:Array<Term>, ?options:TermOptions);
	TChanges(args:Array<Term>, ?options:TermOptions);
	TArgs(args:Array<Term>, ?options:TermOptions);
	TBinary(args:Array<Term>, ?options:TermOptions);
	TGeojson(args:Array<Term>, ?options:TermOptions);
	TToGeojson(args:Array<Term>, ?options:TermOptions);
	TPoint(args:Array<Term>, ?options:TermOptions);
	TLine(args:Array<Term>, ?options:TermOptions);
	TPolygon(args:Array<Term>, ?options:TermOptions);
	TDistance(args:Array<Term>, ?options:TermOptions);
	TIntersects(args:Array<Term>, ?options:TermOptions);
	TIncludes(args:Array<Term>, ?options:TermOptions);
	TCircle(args:Array<Term>, ?options:TermOptions);
	TGetIntersecting(args:Array<Term>, ?options:TermOptions);
	TFill(args:Array<Term>, ?options:TermOptions);
	TGetNearest(args:Array<Term>, ?options:TermOptions);
	TPolygonSub(args:Array<Term>, ?options:TermOptions);
	TMinval(args:Array<Term>, ?options:TermOptions);
	TMaxval(args:Array<Term>, ?options:TermOptions);
}