package tink.protocol.rethinkdb;

import haxe.Json;
import haxe.io.Bytes;
import haxe.io.BytesOutput;

using tink.CoreApi;

@:forward
abstract Term(TermBase) from TermBase to TermBase {
	@:to
	public function toString():String {
		return switch this {
			case Datum(datum): datum.toString();
			case MakeArray(args, opt): '[$MAKE_ARRAY,${args.toString()}${opt.toString()}]';
			case MakeObj(args, opt): '[$MAKE_OBJ,${args.toString()}${opt.toString()}]';
			case Var(args, opt): '[$VAR,${args.toString()}${opt.toString()}]';
			case Javascript(args, opt): '[$JAVASCRIPT,${args.toString()}${opt.toString()}]';
			case Uuid(args, opt): '[$UUID,${args.toString()}${opt.toString()}]';
			case Http(args, opt): '[$HTTP,${args.toString()}${opt.toString()}]';
			case Error(args, opt): '[$ERROR,${args.toString()}${opt.toString()}]';
			case ImplicitVar(args, opt): '[$IMPLICIT_VAR,${args.toString()}${opt.toString()}]';
			case Db(args, opt): '[$DB,${args.toString()}${opt.toString()}]';
			case Table(args, opt): '[$TABLE,${args.toString()}${opt.toString()}]';
			case Get(args, opt): '[$GET,${args.toString()}${opt.toString()}]';
			case GetAll(args, opt): '[$GET_ALL,${args.toString()}${opt.toString()}]';
			case Eq(args, opt): '[$EQ,${args.toString()}${opt.toString()}]';
			case Ne(args, opt): '[$NE,${args.toString()}${opt.toString()}]';
			case Lt(args, opt): '[$LT,${args.toString()}${opt.toString()}]';
			case Le(args, opt): '[$LE,${args.toString()}${opt.toString()}]';
			case Gt(args, opt): '[$GT,${args.toString()}${opt.toString()}]';
			case Ge(args, opt): '[$GE,${args.toString()}${opt.toString()}]';
			case Not(args, opt): '[$NOT,${args.toString()}${opt.toString()}]';
			case Add(args, opt): '[$ADD,${args.toString()}${opt.toString()}]';
			case Sub(args, opt): '[$SUB,${args.toString()}${opt.toString()}]';
			case Mul(args, opt): '[$MUL,${args.toString()}${opt.toString()}]';
			case Div(args, opt): '[$DIV,${args.toString()}${opt.toString()}]';
			case Mod(args, opt): '[$MOD,${args.toString()}${opt.toString()}]';
			case Floor(args, opt): '[$FLOOR,${args.toString()}${opt.toString()}]';
			case Ceil(args, opt): '[$CEIL,${args.toString()}${opt.toString()}]';
			case Round(args, opt): '[$ROUND,${args.toString()}${opt.toString()}]';
			case Append(args, opt): '[$APPEND,${args.toString()}${opt.toString()}]';
			case Prepend(args, opt): '[$PREPEND,${args.toString()}${opt.toString()}]';
			case Difference(args, opt): '[$DIFFERENCE,${args.toString()}${opt.toString()}]';
			case SetInsert(args, opt): '[$SET_INSERT,${args.toString()}${opt.toString()}]';
			case SetIntersection(args, opt): '[$SET_INTERSECTION,${args.toString()}${opt.toString()}]';
			case SetUnion(args, opt): '[$SET_UNION,${args.toString()}${opt.toString()}]';
			case SetDifference(args, opt): '[$SET_DIFFERENCE,${args.toString()}${opt.toString()}]';
			case Slice(args, opt): '[$SLICE,${args.toString()}${opt.toString()}]';
			case Skip(args, opt): '[$SKIP,${args.toString()}${opt.toString()}]';
			case Limit(args, opt): '[$LIMIT,${args.toString()}${opt.toString()}]';
			case OffsetsOf(args, opt): '[$OFFSETS_OF,${args.toString()}${opt.toString()}]';
			case Contains(args, opt): '[$CONTAINS,${args.toString()}${opt.toString()}]';
			case GetField(args, opt): '[$GET_FIELD,${args.toString()}${opt.toString()}]';
			case Keys(args, opt): '[$KEYS,${args.toString()}${opt.toString()}]';
			case Values(args, opt): '[$VALUES,${args.toString()}${opt.toString()}]';
			case Object(args, opt): '[$OBJECT,${args.toString()}${opt.toString()}]';
			case HasFields(args, opt): '[$HAS_FIELDS,${args.toString()}${opt.toString()}]';
			case WithFields(args, opt): '[$WITH_FIELDS,${args.toString()}${opt.toString()}]';
			case Pluck(args, opt): '[$PLUCK,${args.toString()}${opt.toString()}]';
			case Without(args, opt): '[$WITHOUT,${args.toString()}${opt.toString()}]';
			case Merge(args, opt): '[$MERGE,${args.toString()}${opt.toString()}]';
			case BetweenDeprecated(args, opt): '[$BETWEEN_DEPRECATED,${args.toString()}${opt.toString()}]';
			case Between(args, opt): '[$BETWEEN,${args.toString()}${opt.toString()}]';
			case Reduce(args, opt): '[$REDUCE,${args.toString()}${opt.toString()}]';
			case Map(args, opt): '[$MAP,${args.toString()}${opt.toString()}]';
			case Fold(args, opt): '[$FOLD,${args.toString()}${opt.toString()}]';
			case Filter(args, opt): '[$FILTER,${args.toString()}${opt.toString()}]';
			case ConcatMap(args, opt): '[$CONCAT_MAP,${args.toString()}${opt.toString()}]';
			case OrderBy(args, opt): '[$ORDER_BY,${args.toString()}${opt.toString()}]';
			case Distinct(args, opt): '[$DISTINCT,${args.toString()}${opt.toString()}]';
			case Count(args, opt): '[$COUNT,${args.toString()}${opt.toString()}]';
			case IsEmpty(args, opt): '[$IS_EMPTY,${args.toString()}${opt.toString()}]';
			case Union(args, opt): '[$UNION,${args.toString()}${opt.toString()}]';
			case Nth(args, opt): '[$NTH,${args.toString()}${opt.toString()}]';
			case Bracket(args, opt): '[$BRACKET,${args.toString()}${opt.toString()}]';
			case InnerJoin(args, opt): '[$INNER_JOIN,${args.toString()}${opt.toString()}]';
			case OuterJoin(args, opt): '[$OUTER_JOIN,${args.toString()}${opt.toString()}]';
			case EqJoin(args, opt): '[$EQ_JOIN,${args.toString()}${opt.toString()}]';
			case Zip(args, opt): '[$ZIP,${args.toString()}${opt.toString()}]';
			case Range(args, opt): '[$RANGE,${args.toString()}${opt.toString()}]';
			case InsertAt(args, opt): '[$INSERT_AT,${args.toString()}${opt.toString()}]';
			case DeleteAt(args, opt): '[$DELETE_AT,${args.toString()}${opt.toString()}]';
			case ChangeAt(args, opt): '[$CHANGE_AT,${args.toString()}${opt.toString()}]';
			case SpliceAt(args, opt): '[$SPLICE_AT,${args.toString()}${opt.toString()}]';
			case CoerceTo(args, opt): '[$COERCE_TO,${args.toString()}${opt.toString()}]';
			case TypeOf(args, opt): '[$TYPE_OF,${args.toString()}${opt.toString()}]';
			case Update(args, opt): '[$UPDATE,${args.toString()}${opt.toString()}]';
			case Delete(args, opt): '[$DELETE,${args.toString()}${opt.toString()}]';
			case Replace(args, opt): '[$REPLACE,${args.toString()}${opt.toString()}]';
			case Insert(args, opt): '[$INSERT,${args.toString()}${opt.toString()}]';
			case DbCreate(args, opt): '[$DB_CREATE,${args.toString()}${opt.toString()}]';
			case DbDrop(args, opt): '[$DB_DROP,${args.toString()}${opt.toString()}]';
			case DbList(args, opt): '[$DB_LIST,${args.toString()}${opt.toString()}]';
			case TableCreate(args, opt): '[$TABLE_CREATE,${args.toString()}${opt.toString()}]';
			case TableDrop(args, opt): '[$TABLE_DROP,${args.toString()}${opt.toString()}]';
			case TableList(args, opt): '[$TABLE_LIST,${args.toString()}${opt.toString()}]';
			case Config(args, opt): '[$CONFIG,${args.toString()}${opt.toString()}]';
			case Status(args, opt): '[$STATUS,${args.toString()}${opt.toString()}]';
			case Wait(args, opt): '[$WAIT,${args.toString()}${opt.toString()}]';
			case Reconfigure(args, opt): '[$RECONFIGURE,${args.toString()}${opt.toString()}]';
			case Rebalance(args, opt): '[$REBALANCE,${args.toString()}${opt.toString()}]';
			case Sync(args, opt): '[$SYNC,${args.toString()}${opt.toString()}]';
			case Grant(args, opt): '[$GRANT,${args.toString()}${opt.toString()}]';
			case IndexCreate(args, opt): '[$INDEX_CREATE,${args.toString()}${opt.toString()}]';
			case IndexDrop(args, opt): '[$INDEX_DROP,${args.toString()}${opt.toString()}]';
			case IndexList(args, opt): '[$INDEX_LIST,${args.toString()}${opt.toString()}]';
			case IndexStatus(args, opt): '[$INDEX_STATUS,${args.toString()}${opt.toString()}]';
			case IndexWait(args, opt): '[$INDEX_WAIT,${args.toString()}${opt.toString()}]';
			case IndexRename(args, opt): '[$INDEX_RENAME,${args.toString()}${opt.toString()}]';
			case SetWriteHook(args, opt): '[$SET_WRITE_HOOK,${args.toString()}${opt.toString()}]';
			case GetWriteHook(args, opt): '[$GET_WRITE_HOOK,${args.toString()}${opt.toString()}]';
			case Funcall(args, opt): '[$FUNCALL,${args.toString()}${opt.toString()}]';
			case Branch(args, opt): '[$BRANCH,${args.toString()}${opt.toString()}]';
			case Or(args, opt): '[$OR,${args.toString()}${opt.toString()}]';
			case And(args, opt): '[$AND,${args.toString()}${opt.toString()}]';
			case ForEach(args, opt): '[$FOR_EACH,${args.toString()}${opt.toString()}]';
			case Func(args, opt): '[$FUNC,${args.toString()}${opt.toString()}]';
			case Asc(args, opt): '[$ASC,${args.toString()}${opt.toString()}]';
			case Desc(args, opt): '[$DESC,${args.toString()}${opt.toString()}]';
			case Info(args, opt): '[$INFO,${args.toString()}${opt.toString()}]';
			case Match(args, opt): '[$MATCH,${args.toString()}${opt.toString()}]';
			case Upcase(args, opt): '[$UPCASE,${args.toString()}${opt.toString()}]';
			case Downcase(args, opt): '[$DOWNCASE,${args.toString()}${opt.toString()}]';
			case Sample(args, opt): '[$SAMPLE,${args.toString()}${opt.toString()}]';
			case Default(args, opt): '[$DEFAULT,${args.toString()}${opt.toString()}]';
			case Json(args, opt): '[$JSON,${args.toString()}${opt.toString()}]';
			case ToJsonString(args, opt): '[$TO_JSON_STRING,${args.toString()}${opt.toString()}]';
			case Iso8601(args, opt): '[$ISO8601,${args.toString()}${opt.toString()}]';
			case ToIso8601(args, opt): '[$TO_ISO8601,${args.toString()}${opt.toString()}]';
			case EpochTime(args, opt): '[$EPOCH_TIME,${args.toString()}${opt.toString()}]';
			case ToEpochTime(args, opt): '[$TO_EPOCH_TIME,${args.toString()}${opt.toString()}]';
			case Now(args, opt): '[$NOW,${args.toString()}${opt.toString()}]';
			case InTimezone(args, opt): '[$IN_TIMEZONE,${args.toString()}${opt.toString()}]';
			case During(args, opt): '[$DURING,${args.toString()}${opt.toString()}]';
			case Date(args, opt): '[$DATE,${args.toString()}${opt.toString()}]';
			case TimeOfDay(args, opt): '[$TIME_OF_DAY,${args.toString()}${opt.toString()}]';
			case Timezone(args, opt): '[$TIMEZONE,${args.toString()}${opt.toString()}]';
			case Year(args, opt): '[$YEAR,${args.toString()}${opt.toString()}]';
			case Month(args, opt): '[$MONTH,${args.toString()}${opt.toString()}]';
			case Day(args, opt): '[$DAY,${args.toString()}${opt.toString()}]';
			case DayOfWeek(args, opt): '[$DAY_OF_WEEK,${args.toString()}${opt.toString()}]';
			case DayOfYear(args, opt): '[$DAY_OF_YEAR,${args.toString()}${opt.toString()}]';
			case Hours(args, opt): '[$HOURS,${args.toString()}${opt.toString()}]';
			case Minutes(args, opt): '[$MINUTES,${args.toString()}${opt.toString()}]';
			case Seconds(args, opt): '[$SECONDS,${args.toString()}${opt.toString()}]';
			case Time(args, opt): '[$TIME,${args.toString()}${opt.toString()}]';
			case Monday(args, opt): '[$MONDAY,${args.toString()}${opt.toString()}]';
			case Tuesday(args, opt): '[$TUESDAY,${args.toString()}${opt.toString()}]';
			case Wednesday(args, opt): '[$WEDNESDAY,${args.toString()}${opt.toString()}]';
			case Thursday(args, opt): '[$THURSDAY,${args.toString()}${opt.toString()}]';
			case Friday(args, opt): '[$FRIDAY,${args.toString()}${opt.toString()}]';
			case Saturday(args, opt): '[$SATURDAY,${args.toString()}${opt.toString()}]';
			case Sunday(args, opt): '[$SUNDAY,${args.toString()}${opt.toString()}]';
			case January(args, opt): '[$JANUARY,${args.toString()}${opt.toString()}]';
			case February(args, opt): '[$FEBRUARY,${args.toString()}${opt.toString()}]';
			case March(args, opt): '[$MARCH,${args.toString()}${opt.toString()}]';
			case April(args, opt): '[$APRIL,${args.toString()}${opt.toString()}]';
			case May(args, opt): '[$MAY,${args.toString()}${opt.toString()}]';
			case June(args, opt): '[$JUNE,${args.toString()}${opt.toString()}]';
			case July(args, opt): '[$JULY,${args.toString()}${opt.toString()}]';
			case August(args, opt): '[$AUGUST,${args.toString()}${opt.toString()}]';
			case September(args, opt): '[$SEPTEMBER,${args.toString()}${opt.toString()}]';
			case October(args, opt): '[$OCTOBER,${args.toString()}${opt.toString()}]';
			case November(args, opt): '[$NOVEMBER,${args.toString()}${opt.toString()}]';
			case December(args, opt): '[$DECEMBER,${args.toString()}${opt.toString()}]';
			case Literal(args, opt): '[$LITERAL,${args.toString()}${opt.toString()}]';
			case Group(args, opt): '[$GROUP,${args.toString()}${opt.toString()}]';
			case Sum(args, opt): '[$SUM,${args.toString()}${opt.toString()}]';
			case Avg(args, opt): '[$AVG,${args.toString()}${opt.toString()}]';
			case Min(args, opt): '[$MIN,${args.toString()}${opt.toString()}]';
			case Max(args, opt): '[$MAX,${args.toString()}${opt.toString()}]';
			case Split(args, opt): '[$SPLIT,${args.toString()}${opt.toString()}]';
			case Ungroup(args, opt): '[$UNGROUP,${args.toString()}${opt.toString()}]';
			case Random(args, opt): '[$RANDOM,${args.toString()}${opt.toString()}]';
			case Changes(args, opt): '[$CHANGES,${args.toString()}${opt.toString()}]';
			case Args(args, opt): '[$ARGS,${args.toString()}${opt.toString()}]';
			case Binary(args, opt): '[$BINARY,${args.toString()}${opt.toString()}]';
			case Geojson(args, opt): '[$GEOJSON,${args.toString()}${opt.toString()}]';
			case ToGeojson(args, opt): '[$TO_GEOJSON,${args.toString()}${opt.toString()}]';
			case Point(args, opt): '[$POINT,${args.toString()}${opt.toString()}]';
			case Line(args, opt): '[$LINE,${args.toString()}${opt.toString()}]';
			case Polygon(args, opt): '[$POLYGON,${args.toString()}${opt.toString()}]';
			case Distance(args, opt): '[$DISTANCE,${args.toString()}${opt.toString()}]';
			case Intersects(args, opt): '[$INTERSECTS,${args.toString()}${opt.toString()}]';
			case Includes(args, opt): '[$INCLUDES,${args.toString()}${opt.toString()}]';
			case Circle(args, opt): '[$CIRCLE,${args.toString()}${opt.toString()}]';
			case GetIntersecting(args, opt): '[$GET_INTERSECTING,${args.toString()}${opt.toString()}]';
			case Fill(args, opt): '[$FILL,${args.toString()}${opt.toString()}]';
			case GetNearest(args, opt): '[$GET_NEAREST,${args.toString()}${opt.toString()}]';
			case PolygonSub(args, opt): '[$POLYGON_SUB,${args.toString()}${opt.toString()}]';
			case Minval(args, opt): '[$MINVAL,${args.toString()}${opt.toString()}]';
			case Maxval(args, opt): '[$MAXVAL,${args.toString()}${opt.toString()}]';
		}
	}
}

abstract TermArgs(Array<Term>) from Array<Term> {
	@:to
	public function toString():String
		return '[' + [for(i in this) i.toString()].join(',') + ']';

}

abstract TermOptions(Array<Named<Term>>) from Array<Named<Term>> {
	@:to
	public function toString():String
		return this == null ? '' : ',{' + [for(o in this) '"${o.name}":${o.value}'].join(',') + '}';
}

@:enum
abstract TermType(Int) from Int {
	var DATUM = 1;
	var MAKE_ARRAY = 2;
	var MAKE_OBJ = 3;
	var VAR = 10;
	var JAVASCRIPT = 11;
	var UUID = 169;
	var HTTP = 153;
	var ERROR = 12;
	var IMPLICIT_VAR = 13;
	var DB = 14;
	var TABLE = 15;
	var GET = 16;
	var GET_ALL = 78;
	var EQ = 17;
	var NE = 18;
	var LT = 19;
	var LE = 20;
	var GT = 21;
	var GE = 22;
	var NOT = 23;
	var ADD = 24;
	var SUB = 25;
	var MUL = 26;
	var DIV = 27;
	var MOD = 28;
	var FLOOR = 183;
	var CEIL = 184;
	var ROUND = 185;
	var APPEND = 29;
	var PREPEND = 80;
	var DIFFERENCE = 95;
	var SET_INSERT = 88;
	var SET_INTERSECTION = 89;
	var SET_UNION = 90;
	var SET_DIFFERENCE = 91;
	var SLICE = 30;
	var SKIP = 70;
	var LIMIT = 71;
	var OFFSETS_OF = 87;
	var CONTAINS = 93;
	var GET_FIELD = 31;
	var KEYS = 94;
	var VALUES = 186;
	var OBJECT = 143;
	var HAS_FIELDS = 32;
	var WITH_FIELDS = 96;
	var PLUCK = 33;
	var WITHOUT = 34;
	var MERGE = 35;
	var BETWEEN_DEPRECATED = 36;
	var BETWEEN = 182;
	var REDUCE = 37;
	var MAP = 38;
	var FOLD = 187;
	var FILTER = 39;
	var CONCAT_MAP = 40;
	var ORDER_BY = 41;
	var DISTINCT = 42;
	var COUNT = 43;
	var IS_EMPTY = 86;
	var UNION = 44;
	var NTH = 45;
	var BRACKET = 170;
	var INNER_JOIN = 48;
	var OUTER_JOIN = 49;
	var EQ_JOIN = 50;
	var ZIP = 72;
	var RANGE = 173;
	var INSERT_AT = 82;
	var DELETE_AT = 83;
	var CHANGE_AT = 84;
	var SPLICE_AT = 85;
	var COERCE_TO = 51;
	var TYPE_OF = 52;
	var UPDATE = 53;
	var DELETE = 54;
	var REPLACE = 55;
	var INSERT = 56;
	var DB_CREATE = 57;
	var DB_DROP = 58;
	var DB_LIST = 59;
	var TABLE_CREATE = 60;
	var TABLE_DROP = 61;
	var TABLE_LIST = 62;
	var CONFIG = 174;
	var STATUS = 175;
	var WAIT = 177;
	var RECONFIGURE = 176;
	var REBALANCE = 179;
	var SYNC = 138;
	var GRANT = 188;
	var INDEX_CREATE = 75;
	var INDEX_DROP = 76;
	var INDEX_LIST = 77;
	var INDEX_STATUS = 139;
	var INDEX_WAIT = 140;
	var INDEX_RENAME = 156;
	var SET_WRITE_HOOK = 189;
	var GET_WRITE_HOOK = 190;
	var FUNCALL = 64;
	var BRANCH = 65;
	var OR = 66;
	var AND = 67;
	var FOR_EACH = 68;
	var FUNC = 69;
	var ASC = 73;
	var DESC = 74;
	var INFO = 79;
	var MATCH = 97;
	var UPCASE = 141;
	var DOWNCASE = 142;
	var SAMPLE = 81;
	var DEFAULT = 92;
	var JSON = 98;
	var TO_JSON_STRING = 172;
	var ISO8601 = 99;
	var TO_ISO8601 = 100;
	var EPOCH_TIME = 101;
	var TO_EPOCH_TIME = 102;
	var NOW = 103;
	var IN_TIMEZONE = 104;
	var DURING = 105;
	var DATE = 106;
	var TIME_OF_DAY = 126;
	var TIMEZONE = 127;
	var YEAR = 128;
	var MONTH = 129;
	var DAY = 130;
	var DAY_OF_WEEK = 131;
	var DAY_OF_YEAR = 132;
	var HOURS = 133;
	var MINUTES = 134;
	var SECONDS = 135;
	var TIME = 136;
	var MONDAY = 107;
	var TUESDAY = 108;
	var WEDNESDAY = 109;
	var THURSDAY = 110;
	var FRIDAY = 111;
	var SATURDAY = 112;
	var SUNDAY = 113;
	var JANUARY = 114;
	var FEBRUARY = 115;
	var MARCH = 116;
	var APRIL = 117;
	var MAY = 118;
	var JUNE = 119;
	var JULY = 120;
	var AUGUST = 121;
	var SEPTEMBER = 122;
	var OCTOBER = 123;
	var NOVEMBER = 124;
	var DECEMBER = 125;
	var LITERAL = 137;
	var GROUP = 144;
	var SUM = 145;
	var AVG = 146;
	var MIN = 147;
	var MAX = 148;
	var SPLIT = 149;
	var UNGROUP = 150;
	var RANDOM = 151;
	var CHANGES = 152;
	var ARGS = 154;
	var BINARY = 155;
	var GEOJSON = 157;
	var TO_GEOJSON = 158;
	var POINT = 159;
	var LINE = 160;
	var POLYGON = 161;
	var DISTANCE = 162;
	var INTERSECTS = 163;
	var INCLUDES = 164;
	var CIRCLE = 165;
	var GET_INTERSECTING = 166;
	var FILL = 167;
	var GET_NEAREST = 168;
	var POLYGON_SUB = 171;
	var MINVAL = 180;
	var MAXVAL = 181;
}

enum TermBase {
	Datum(datum:Datum);
	MakeArray(args:TermArgs, ?options:TermOptions);
	MakeObj(args:TermArgs, ?options:TermOptions);
	Var(args:TermArgs, ?options:TermOptions);
	Javascript(args:TermArgs, ?options:TermOptions);
	Uuid(args:TermArgs, ?options:TermOptions);
	Http(args:TermArgs, ?options:TermOptions);
	Error(args:TermArgs, ?options:TermOptions);
	ImplicitVar(args:TermArgs, ?options:TermOptions);
	Db(args:TermArgs, ?options:TermOptions);
	Table(args:TermArgs, ?options:TermOptions);
	Get(args:TermArgs, ?options:TermOptions);
	GetAll(args:TermArgs, ?options:TermOptions);
	Eq(args:TermArgs, ?options:TermOptions);
	Ne(args:TermArgs, ?options:TermOptions);
	Lt(args:TermArgs, ?options:TermOptions);
	Le(args:TermArgs, ?options:TermOptions);
	Gt(args:TermArgs, ?options:TermOptions);
	Ge(args:TermArgs, ?options:TermOptions);
	Not(args:TermArgs, ?options:TermOptions);
	Add(args:TermArgs, ?options:TermOptions);
	Sub(args:TermArgs, ?options:TermOptions);
	Mul(args:TermArgs, ?options:TermOptions);
	Div(args:TermArgs, ?options:TermOptions);
	Mod(args:TermArgs, ?options:TermOptions);
	Floor(args:TermArgs, ?options:TermOptions);
	Ceil(args:TermArgs, ?options:TermOptions);
	Round(args:TermArgs, ?options:TermOptions);
	Append(args:TermArgs, ?options:TermOptions);
	Prepend(args:TermArgs, ?options:TermOptions);
	Difference(args:TermArgs, ?options:TermOptions);
	SetInsert(args:TermArgs, ?options:TermOptions);
	SetIntersection(args:TermArgs, ?options:TermOptions);
	SetUnion(args:TermArgs, ?options:TermOptions);
	SetDifference(args:TermArgs, ?options:TermOptions);
	Slice(args:TermArgs, ?options:TermOptions);
	Skip(args:TermArgs, ?options:TermOptions);
	Limit(args:TermArgs, ?options:TermOptions);
	OffsetsOf(args:TermArgs, ?options:TermOptions);
	Contains(args:TermArgs, ?options:TermOptions);
	GetField(args:TermArgs, ?options:TermOptions);
	Keys(args:TermArgs, ?options:TermOptions);
	Values(args:TermArgs, ?options:TermOptions);
	Object(args:TermArgs, ?options:TermOptions);
	HasFields(args:TermArgs, ?options:TermOptions);
	WithFields(args:TermArgs, ?options:TermOptions);
	Pluck(args:TermArgs, ?options:TermOptions);
	Without(args:TermArgs, ?options:TermOptions);
	Merge(args:TermArgs, ?options:TermOptions);
	BetweenDeprecated(args:TermArgs, ?options:TermOptions);
	Between(args:TermArgs, ?options:TermOptions);
	Reduce(args:TermArgs, ?options:TermOptions);
	Map(args:TermArgs, ?options:TermOptions);
	Fold(args:TermArgs, ?options:TermOptions);
	Filter(args:TermArgs, ?options:TermOptions);
	ConcatMap(args:TermArgs, ?options:TermOptions);
	OrderBy(args:TermArgs, ?options:TermOptions);
	Distinct(args:TermArgs, ?options:TermOptions);
	Count(args:TermArgs, ?options:TermOptions);
	IsEmpty(args:TermArgs, ?options:TermOptions);
	Union(args:TermArgs, ?options:TermOptions);
	Nth(args:TermArgs, ?options:TermOptions);
	Bracket(args:TermArgs, ?options:TermOptions);
	InnerJoin(args:TermArgs, ?options:TermOptions);
	OuterJoin(args:TermArgs, ?options:TermOptions);
	EqJoin(args:TermArgs, ?options:TermOptions);
	Zip(args:TermArgs, ?options:TermOptions);
	Range(args:TermArgs, ?options:TermOptions);
	InsertAt(args:TermArgs, ?options:TermOptions);
	DeleteAt(args:TermArgs, ?options:TermOptions);
	ChangeAt(args:TermArgs, ?options:TermOptions);
	SpliceAt(args:TermArgs, ?options:TermOptions);
	CoerceTo(args:TermArgs, ?options:TermOptions);
	TypeOf(args:TermArgs, ?options:TermOptions);
	Update(args:TermArgs, ?options:TermOptions);
	Delete(args:TermArgs, ?options:TermOptions);
	Replace(args:TermArgs, ?options:TermOptions);
	Insert(args:TermArgs, ?options:TermOptions);
	DbCreate(args:TermArgs, ?options:TermOptions);
	DbDrop(args:TermArgs, ?options:TermOptions);
	DbList(args:TermArgs, ?options:TermOptions);
	TableCreate(args:TermArgs, ?options:TermOptions);
	TableDrop(args:TermArgs, ?options:TermOptions);
	TableList(args:TermArgs, ?options:TermOptions);
	Config(args:TermArgs, ?options:TermOptions);
	Status(args:TermArgs, ?options:TermOptions);
	Wait(args:TermArgs, ?options:TermOptions);
	Reconfigure(args:TermArgs, ?options:TermOptions);
	Rebalance(args:TermArgs, ?options:TermOptions);
	Sync(args:TermArgs, ?options:TermOptions);
	Grant(args:TermArgs, ?options:TermOptions);
	IndexCreate(args:TermArgs, ?options:TermOptions);
	IndexDrop(args:TermArgs, ?options:TermOptions);
	IndexList(args:TermArgs, ?options:TermOptions);
	IndexStatus(args:TermArgs, ?options:TermOptions);
	IndexWait(args:TermArgs, ?options:TermOptions);
	IndexRename(args:TermArgs, ?options:TermOptions);
	SetWriteHook(args:TermArgs, ?options:TermOptions);
	GetWriteHook(args:TermArgs, ?options:TermOptions);
	Funcall(args:TermArgs, ?options:TermOptions);
	Branch(args:TermArgs, ?options:TermOptions);
	Or(args:TermArgs, ?options:TermOptions);
	And(args:TermArgs, ?options:TermOptions);
	ForEach(args:TermArgs, ?options:TermOptions);
	Func(args:TermArgs, ?options:TermOptions);
	Asc(args:TermArgs, ?options:TermOptions);
	Desc(args:TermArgs, ?options:TermOptions);
	Info(args:TermArgs, ?options:TermOptions);
	Match(args:TermArgs, ?options:TermOptions);
	Upcase(args:TermArgs, ?options:TermOptions);
	Downcase(args:TermArgs, ?options:TermOptions);
	Sample(args:TermArgs, ?options:TermOptions);
	Default(args:TermArgs, ?options:TermOptions);
	Json(args:TermArgs, ?options:TermOptions);
	ToJsonString(args:TermArgs, ?options:TermOptions);
	Iso8601(args:TermArgs, ?options:TermOptions);
	ToIso8601(args:TermArgs, ?options:TermOptions);
	EpochTime(args:TermArgs, ?options:TermOptions);
	ToEpochTime(args:TermArgs, ?options:TermOptions);
	Now(args:TermArgs, ?options:TermOptions);
	InTimezone(args:TermArgs, ?options:TermOptions);
	During(args:TermArgs, ?options:TermOptions);
	Date(args:TermArgs, ?options:TermOptions);
	TimeOfDay(args:TermArgs, ?options:TermOptions);
	Timezone(args:TermArgs, ?options:TermOptions);
	Year(args:TermArgs, ?options:TermOptions);
	Month(args:TermArgs, ?options:TermOptions);
	Day(args:TermArgs, ?options:TermOptions);
	DayOfWeek(args:TermArgs, ?options:TermOptions);
	DayOfYear(args:TermArgs, ?options:TermOptions);
	Hours(args:TermArgs, ?options:TermOptions);
	Minutes(args:TermArgs, ?options:TermOptions);
	Seconds(args:TermArgs, ?options:TermOptions);
	Time(args:TermArgs, ?options:TermOptions);
	Monday(args:TermArgs, ?options:TermOptions);
	Tuesday(args:TermArgs, ?options:TermOptions);
	Wednesday(args:TermArgs, ?options:TermOptions);
	Thursday(args:TermArgs, ?options:TermOptions);
	Friday(args:TermArgs, ?options:TermOptions);
	Saturday(args:TermArgs, ?options:TermOptions);
	Sunday(args:TermArgs, ?options:TermOptions);
	January(args:TermArgs, ?options:TermOptions);
	February(args:TermArgs, ?options:TermOptions);
	March(args:TermArgs, ?options:TermOptions);
	April(args:TermArgs, ?options:TermOptions);
	May(args:TermArgs, ?options:TermOptions);
	June(args:TermArgs, ?options:TermOptions);
	July(args:TermArgs, ?options:TermOptions);
	August(args:TermArgs, ?options:TermOptions);
	September(args:TermArgs, ?options:TermOptions);
	October(args:TermArgs, ?options:TermOptions);
	November(args:TermArgs, ?options:TermOptions);
	December(args:TermArgs, ?options:TermOptions);
	Literal(args:TermArgs, ?options:TermOptions);
	Group(args:TermArgs, ?options:TermOptions);
	Sum(args:TermArgs, ?options:TermOptions);
	Avg(args:TermArgs, ?options:TermOptions);
	Min(args:TermArgs, ?options:TermOptions);
	Max(args:TermArgs, ?options:TermOptions);
	Split(args:TermArgs, ?options:TermOptions);
	Ungroup(args:TermArgs, ?options:TermOptions);
	Random(args:TermArgs, ?options:TermOptions);
	Changes(args:TermArgs, ?options:TermOptions);
	Args(args:TermArgs, ?options:TermOptions);
	Binary(args:TermArgs, ?options:TermOptions);
	Geojson(args:TermArgs, ?options:TermOptions);
	ToGeojson(args:TermArgs, ?options:TermOptions);
	Point(args:TermArgs, ?options:TermOptions);
	Line(args:TermArgs, ?options:TermOptions);
	Polygon(args:TermArgs, ?options:TermOptions);
	Distance(args:TermArgs, ?options:TermOptions);
	Intersects(args:TermArgs, ?options:TermOptions);
	Includes(args:TermArgs, ?options:TermOptions);
	Circle(args:TermArgs, ?options:TermOptions);
	GetIntersecting(args:TermArgs, ?options:TermOptions);
	Fill(args:TermArgs, ?options:TermOptions);
	GetNearest(args:TermArgs, ?options:TermOptions);
	PolygonSub(args:TermArgs, ?options:TermOptions);
	Minval(args:TermArgs, ?options:TermOptions);
	Maxval(args:TermArgs, ?options:TermOptions);
}